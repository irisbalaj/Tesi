\fancyhead[LO, RE] {Sviluppo}
\section{Sviluppo}
\subsection{Sviluppo programma di export}
La versione iniziale del programma di export è stata sviluppata nel 2007 da uno dei programmatori attualmente presenti in azienda e si basa sulla creazione di file di testo che vengono inviati al fornitore, perché si occupi di caricare i database degli showroom della campagna vendite.\\
Dato che la decisione per l'upgrade è stata quella di utilizzare dei DbLink, sotto consiglio del tutor aziendale il primo passo è stato creare una copia esatta delle tabelle dei database di destinazione, all'interno del database di sviluppo, sul quale è stato sviluppato il prototipo. Il motivo della copia è che al momento della scrittura remota tramite dblink sarebbe stato molto più semplice fare un riversamento del contenuto di una tabella all'interno di un'altra, ed in puù in questo modo si ha una versione di backup locale dei dati, in modo che se ci dovessero essere errori nel trasferimento, utilizzando i vari sistemi di tracciamento adottati, che vedremo in seguito nello specifico, si può correggere facilmente ogni problematica. Inoltre in un sistema Eterogeneo (ovvero collegamento fra database server di tipo diverso, Oracle to Sql Server) non si possono eseguire manipolazioni dei dati all'interno delle query di inserimento, come ad esempio conversioni o formattazioni, che vengono quindi anticipate alla fase di caricamento nella parte locale.\\
Una volta create tutte le tabelle locali, il passo successivo è stato prendere spunto dalle query del programma esistente ed ottenere tutti i dati necessari a ricreare le nuove query, con alcune modifiche proposte dai service manager, per popolarle. L'esecuzione del programma prevede anche degli input che talvolta possono essere facoltativi, ma la loro presenza va considerata all'interno delle query e ciò comporta l'utilizzo dei \textbf{refcursor} per permettere una parametrizzazione della query.\\
Durante il popolamento della tabella locale, viene valorizzato il campo di log 'Data\_modifica' che verrà in seguito utilizzato per capire quali dati riversare nel database remoto, confrontandola con la data impostata all'inizio di esecuzione del programma.
Di seguito vediamo la porzione di codice che mostra il percorso di estrazione dati, popolamento della tabella locale ed infine popolamento della tabella remota relativa ai Modelli-Colore, ovvero i dati anagrafici dei Modelli-Parte con l'aggiunta dei colori abilitati agli eventi specificati nella schedulazione del programma.\\

\begin{lstlisting}
v_query :=
 'Select Distinct
  t.annullato,' ||
'substr(t.cd_stagiov,1,4) mod_annorif ,' ||
'Substr(t.cd_stagiov,5,1) mod_codsta ,' ||
't.cd_linea mod_codlin ,' ||
'substr(t.cd_linea,1,2) mod_codmar ,' ||
't.cd_modello mod_codmod ,' ||
't.cd_varia mod_codvar ,' ||
't.cd_ana cd_ana,' ||
't.cd_artico mod_codart ,' ||
't.carco mod_codcarco,' ||
't.modparid mod_mod_par_id ,' ||
't.modid mod_mod_id ,' ||
't.parid mod_par_id ,' ||
'view_col.co_cod' ||

'From pindt_ext_modart_crm t, 
(
select co.stg_col_ogg_soc_cod   co_ogg_soc_cod,'|| 
'co.stg_col_col_cod    co_cod,' ||
'co.stg_col_data_mod   co_data_mod,' ||
'co.stg_col_ogg_id   ogg_id' ||

'from s3t_stg_col co' ||

'UNION' ||
' select  colc.stg_col_ogg_soc_cod  co_ogg_soc_cod,' ||
'          colc.stg_col_col_cod   co_cod,' ||
'          colc.stg_col_data_canc  co_data_mod,' ||
'          colc.stg_col_ogg_id   ogg_id' ||

'from ppprtt_stg_col colc' ||

') view_col' ||

'Where  t.modparid = view_col.ogg_id' ||
'AND ((to_char(t.dataupd,''YYYY/MM/DD HH24:MI:SS'') > 
'''||to_char(LastExcutionData,'YYYY/MM/DD HH24:MI:SS')||'''||' 
'        OR' ||
' to_char(view_col.co_data_mod,''YYYY/MM/DD HH24:MI:SS'') > 
'''||to_char(LastExcutionData,'YYYY/MM/DD HH24:MI:SS')||''')'|| 
'       OR' ||
' exists (select 1 from s3t_opb' ||
'where opb_mod_id = t.modid' ||
'  and nvl(opb_f_annu,''0'') = ''0''' ||
'and to_char(opb_data_mod,''YYYY/MM/DD HH24:MI:SS'') > 
'''||to_char(LastExcutionData,'YYYY/MM/DD HH24:MI:SS')||'''))' ||
'   AND t.carco IS NOT NULL' ||
'    And substr(t.cd_stagiov,1,4) ||''/''||
    Substr(t.cd_stagiov,5,1) = '''||P_STG_ATT||''' '|| 
'    and t.societa = '''||s3ksysglobal.Soc_Ute||''' ';

IF v_mrc_lis IS NOT NULL THEN
   v_query := v_query ||
 '  And Substr(t.cd_linea,1,2) in ('''||v_mrc_lis||''')';
END IF;
IF v_lnv IS NOT NULL THEN
    v_query := v_query || 
      ' And t.cd_linea in ('''||v_lnv||''')';
    
  END IF;
  
  v_query := v_query ||
 ' UNION' ||
'  select DISTINCT mp.ogg_f_annu,' ||
'        substr(mp.ogg_stg_anno,1,4),' ||
'        substr(mp.ogg_stg_cod,1,1),' ||
'        s.ogg_soc_lin_cod,' ||
'        substr(s.ogg_soc_lin_cod,1,2),' ||
'        substr(m.ogg_cod,6,5),' ||
'        substr(m.ogg_cod,11,2),' ||
'        substr(m.ogg_cod,1,5),' ||
'        p.ogg_cod,' ||
'        substr(mp.dagg_num5,1,3),' ||
'        mp.ogg_id,' ||
'        m.ogg_id,' ||
'        p.ogg_id,' ||
'       b.opb_col_cod' ||
'from pindt_ext_modart_crm t, s3t_opb b, 
         s3t_ogg mp, s3t_ogg m, s3t_ogg p, s3t_ogg_soc s'|| 
'where t.modid  (+)= b.opb_mod_id' ||
'    and t.parid  (+)= b.opb_par_id' ||
'    and t.societa(+)= b.opb_soc_cod' ||
'and to_char(b.opb_data_mod,''YYYY/MM/DD HH24:MI:SS'') > 
'''||to_char(LastExcutionData,'YYYY/MM/DD HH24:MI:SS')||''''|| 
' and t.cd_modello IS NULL' ||
' and mp.ogg_tipo = ''5''' ||
'and mp.ogg_soc_cod = b.opb_ogg_soc_cod' ||
'and mp.ogg_mod_id = b.opb_mod_id' ||
'and mp.ogg_par_id = b.opb_par_id' ||
'and m.ogg_tipo = ''1''' ||
'and mp.ogg_soc_cod = m.ogg_soc_cod' ||
'and mp.ogg_mod_id = m.ogg_id' ||
'and p.ogg_tipo = ''3''' ||
'and mp.ogg_soc_cod = p.ogg_soc_cod' ||
'and mp.ogg_par_id = p.ogg_id' ||
'and s.ogg_soc_ogg_soc_cod = mp.ogg_soc_cod' ||
'and s.ogg_soc_ogg_id = m.ogg_id' ||
'and mp.dagg_num5 is not null' ||
'and mp.ogg_soc_cod = 
s3ksysutils.SocPubPriv('''||s3ksysglobal.soc_ute||''', ''OGG'')';

IF v_mrc_lis IS NOT NULL THEN
   v_query := v_query || 
     ' And Substr(s.ogg_soc_lin_cod,1,2) in ('''||v_mrc_lis||''')';
END IF;
IF v_lnv IS NOT NULL THEN
    v_query := v_query || 
' And s.ogg_soc_lin_cod in ('''||v_lnv||''')';
    
  END IF;
\end{lstlisting}
La sintassi di PL/SQL prevede che la concatenazione fra stringhe di testo (delimitate da apici) avvenga tramite il 'pipe' due volte in successione, inoltre l'inserimento di una variabile all'interno della stringa va gestito con cautela, in quanto va fatta una distinzione sul tipo della variabile inserita: \\
\begin{itemize}
\item se è di tipo alfanumerico vanno utilizzati 3 apici in chiusura della stringa, seguiti dalla variabile ed a sua volta seguita da altri 3 apici, ogni parte concatenata con l'altra; questo perché ci deve essere una forma di escape tra gli apici che distinguono il testo della query in stato di stringa ed il contenuto della variabile, che in Run-Time, quando viene effettivamente eseguita la query, diventa un valore alfanumerico senza significato per un compilatore, non utilizzabile in un confronto o una selezione.\\
\item se è di tpo intero basta una concatenazione senza apici aggiuntivi
\end{itemize}

La fase successiva all'estrazione dei dati è quella di caricarli nella tabella locale dei modelli-parte-colore.
\begin{lstlisting}
LOOP
  fetch Cur_modcol into 
           f_annu_col, mod_annorif_col,
           mod_codsta_col, mod_codlin_col,
           mod_codmar_col, mod_codmod_col,
           mod_codvar_col, cd_ana_col,
           mod_codart_col, mod_codcarco_col,
           mod_mod_par_id_col, mod_mod_id_col,
           mod_par_id_col, v_col_id;
  exit when Cur_modcol\%notfound;
  
          Open CAblCol(mod_mod_par_id_col, mod_par_id_col, 
			 Mod_Annorif_col, Mod_Codsta_col);
          Loop
            Begin
            Fetch CAblCol Into RAblCol;
            Exit When CAblCol\%Notfound;
            If RAblCol.col_cod<>'000' --colori di campionario

            Then --colori in cartella colori
              --ctr esistenza in cartella colori
              v_col_blc :=Get_Blocco_Colore(
			           Mod_Annorif_col,
                                            Mod_Codsta_col,
                                            Mod_Mod_Par_Id_col,
                                            Mod_Mod_Id_col,
                                            Mod_Par_Id_col,
                                            RAblCol.Col_Cod); 
                                          --Colori Bloccati
              IF v_col_blc IS NULL THEN
                v_col_blc := '0';
              ELSE
                v_col_blc := '1';
              END IF;
	   v_cct_id:=PPPRKOGGCCT.Get_CCT_ID(
		      s3ksysglobal.soc_ute,
                          Mod_Annorif_col,Mod_Codsta_col,
                          Mod_Codmar_col,Mod_Codlin_col,
                          Mod_Par_Id_col,mod_codcarco_col);
              v_esiste:=0;
              If v_esiste=0 AND (v_opb_data_mod>
                                   LastExcutionData 
				  OR
                                RAblCol.sc_data_mod>
			            LastExcutionData) 
       Then 
        BEGIN
         v_img2 := null;
         IF Mod_Codcarco_col IS NOT NULL THEN
           v_img2    := Mod_Annorif_col||
                        Mod_Codsta_col||
                        Mod_Codlin_col||
                        Mod_Codart_col||
                        Mod_Codcarco_col||
                        RAblCol.Col_Cod;
         END IF;
        INSERT INTO PINDT_MODART_CRM(
	                            cd_modello,
                                  cd_varia,
                                 tipoana,
                                 cd_ana,
                                 cd_artico,
                                 cd_cart,
                                 cd_colore,
                                 cd_linea,
                                 datains,
                                 dataupd,
                                 annullato,
                                 cd_stagiov,
                                 imgname,
                                 imgname2,
                                 flagmo,
                                 flagspecial,
                                 disattiva,
                                 col_annu,
                                 societa
                                 )
                   VALUES(Mod_Codmod_col,
                               Mod_Codvar_col,
                               'C',
                               cd_ana_col,
                               Mod_Codart_col,
                               'STD',
                               RAblCol.Col_Cod,
                              mod_codlin_col,
                              LastExcutionData,
                              v_sysd,
                             nvl(v_col_blc,'0'),
                             Mod_Annorif_col||
                             Mod_Codsta_col,
                             Mod_Annorif_col||
                             Mod_Codsta_col||
                             substr(Cd_Ana_col,3)||
                             Mod_Codmod_col||
                             Mod_Codvar_col||
                             Mod_Codart_col||
                             RAblCol.Col_Cod,
                             v_img2,
                              '0',
                              '0',
                              '0',
                              '0',
                             s3ksysglobal.Soc_Ute
                      );
exception
  when dup_val_on_index then
   BEGIN
            UPDATE PINDT_MODART_CRM t 
              SET t.dataupd = v_sysd,
                     t.annullato = nvl(v_col_blc,'0'),
                     t.imgname   = Mod_Annorif_col||
				 Mod_Codsta_col||
                                substr(Cd_Ana_col,3)||
			           Mod_Codmod_col||
                                   Mod_Codvar_col||
                                   Mod_Codart_col||
                                   RAblCol.Col_Cod,
                   t.imgname2  = v_img2,
                   t.col_annu = '0'
       WHERE t.cd_modello = Mod_Codmod_col
        AND t.cd_varia   = Mod_Codvar_col
        AND t.tipoana    = 'C'
        AND t.cd_ana     = Cd_Ana_col
        AND t.cd_artico  = Mod_Codart_col
        AND t.cd_cart    = 'STD'
        AND t.cd_colore  = RAblCol.Col_Cod
        AND t.cd_stagiov = Mod_Annorif_col||
			        Mod_Codsta_col
        AND t.cd_linea   = Mod_Codlin_col 
        and societa    = s3ksysglobal.Soc_Ute;
     exception when others then
         v_error := sqlerrm;
        s3ksysmess.Batch_Messaggi(60070 ,sysdate,
	                  'MODELLO-COLORE: '||
                       nvl(Mod_Codmod_col,'codice null')||'/'||
                       nvl(Mod_Codart_col,'codice null')||'/'||
                       nvl(RAblCol.Col_Cod,'codice null'));
    END;
when others then
    v_error := sqlerrm;
    s3ksysmess.Batch_Messaggi(60070 ,sysdate,
                  'MODELLO-COLORE: '||
                  nvl(Mod_Codmod_col,'codice null')||'/'||
                   nvl(Mod_Codart_col,'codice null')||'/'||
                    nvl(RAblCol.Col_Cod,'codice null'));
 END;
 End If;
End If;
Exception When Others Then
     v_error:=Sqlerrm;
     s3ksysmess.Batch_Messaggi(60070 ,sysdate);
   End;
End Loop;
Close CAblCol ;
\end{lstlisting}

In questo blocco di codice possiamo vedere un'applicazione dei refcursor, il cui contenuto viene iterato per ogni record estratto dalla query definita sopra, ed ogni riga viene utilizzata come testata per un secondo cursore interno, il quale estrae tutti i colori disponibili per quel modello-parte.\\
Si può inoltre vedere una gestione degli errori, permessa dalla struttura \textbf{BEGIN/exception/END} di PLSQL, in cui un errore di tipo 'chiave logica duplicata' viene gestito con un ulteriore blocco in cui viene aggiornato il valore del record per la chiave estratta. Eventuali errori generici vengono gestiti con un sistema di messaggistica sottoforma di Log, messo a disposizione da Stealth
All'inizio della funzione che contiene i due blocchi di codice precedenti, viene assegnato il valore della data attuale alla variabile v\_sysd grazie alla keyword \textbf{sysdate}, e quest'ultima sarà il filtro per decidere quali valori della tabella locale verranno trasferiti nel database remoto, come si vede nel seguente blocco di codice finale:
\begin{lstlisting}
BEGIN
  FOR CUR_MODCOL IN (
     SELECT * FROM PINDT_MODART_CRM t
     WHERE t.dataupd = v_sysd 
          and t.societa = s3ksysglobal.Soc_Ute
        AND t.cd_stagiov = replace(P_STG_ATT,'/')) 
LOOP
    BEGIN
      IF nvl(Cur_modcol.Col_Annu,'0') = '0' THEN
        INSERT INTO modelliarticoli@crm_sydat_eur.industries.com(
                           "Cd_Modello",
                           "Cd_Varia",
                           "TipoAna",
                           "Cd_Ana",
                           "Cd_Artico",
                           "Cd_variat",
                           "Cd_Cart",
                           "Cd_Colore",
                           "CD_Variante",
                           "CD_Lava",
                           "CD_Drop",
                           "CD_Statura",
                           "cd_stagProd",
                           "cd_stagiov",
                           "CD_Flash",
                           "CD_Collez",
                           "Cd_Linea",
                           "imgName",
                           "imgName2",
                           "Annullato",
                           "FlagMO",
                           "FlagSpecial",
                           "Disattiva",
                           "DataUpd",
                           "DataIns",
                           "Cd_TemaC",
                           "Desc_TemaC")
                    VALUES(Cur_modcol.Cd_Modello,
                           Cur_modcol.Cd_Varia,
                           Cur_modcol.Tipoana,
                           Cur_modcol.Cd_Ana,
                           Cur_modcol.Cd_Artico,
                           Cur_modcol.Cd_Variat,
                           Cur_modcol.Cd_Cart,
                           Cur_modcol.Cd_Colore,
                           Cur_modcol.Cd_Variante,
                           Cur_modcol.Cd_Lava,
                           Cur_modcol.Cd_Drop,
                           Cur_modcol.Cd_Statura,
                           Cur_modcol.Cd_Stagprod,
                           Cur_modcol.Cd_Stagiov,
                           Cur_modcol.Cd_Flash,
                           Cur_modcol.Cd_Collez,
                           Cur_modcol.Cd_Linea,
                           Cur_modcol.Imgname,
                           Cur_modcol.Imgname2,
                           Cur_modcol.Annullato,
                           Cur_modcol.Flagmo,
                           Cur_modcol.Flagspecial,
                           Cur_modcol.Disattiva,
                           v_date,
                           v_date,
                           CUr_modcol.Cod_Temac,
                           Cur_modcol.Des_Temac
                           );
        commit;

        v_modelli_par_col_ins := v_modelli_par_col_ins + 1;
      ELSE
        BEGIN
          DELETE FROM modelliarticoli@crm_sydat_eur.industries.com
          WHERE "Cd_Modello"   = Cur_modcol.Cd_Modello
            AND "Cd_Varia"     = Cur_modcol.Cd_Varia
            AND "TipoAna"      = Cur_modcol.Tipoana
            AND "Cd_Ana"       = Cur_modcol.Cd_Ana
            AND "Cd_Artico"    = Cur_modcol.Cd_Artico
            AND "Cd_Cart"      = Cur_modcol.Cd_Cart
            AND "Cd_Colore"    = Cur_modcol.Cd_Colore;
            commit;
          if SQL\%rowcount > 0 then
            v_modelli_par_col_del := v_modelli_par_col_del + 1;
          end if;
        exception when others then
          rollback;
          v_error:= sqlerrm;
          s3ksysmess.Batch_Messaggi(60071 ,sysdate);
        END;
      END IF;
    exception 
      when Dup_Insert then
        BEGIN
          UPDATE modelliarticoli@crm_sydat_eur.industries.com
          SET "Cd_variat"    = Cur_modcol.Cd_Variat,
              "CD_Variante"  = Cur_modcol.Cd_Variante,
              "CD_Lava"      = Cur_modcol.Cd_Lava,
              "CD_Drop"      = Cur_modcol.Cd_Drop,
              "CD_Statura"   = Cur_modcol.Cd_Statura,
              "cd_stagProd"  = Cur_modcol.Cd_Stagprod,
              "cd_stagiov"   = Cur_modcol.Cd_Stagiov,
              "CD_Flash"     = Cur_modcol.Cd_Flash,
              "CD_Collez"    = Cur_modcol.Cd_Collez,
              "Cd_Linea"     = Cur_modcol.Cd_Linea,
              "imgName"      = Cur_modcol.Imgname,
              "imgName2"     = Cur_modcol.Imgname2,
              "Annullato"    = Cur_modcol.Annullato,
              "DataUpd"      = v_date,
              "Cd_TemaC"     = Cur_modcol.Cod_Temac,
              "Desc_TemaC"   = Cur_modcol.Des_Temac
        WHERE "Cd_Modello"   = Cur_modcol.Cd_Modello
          AND "Cd_Varia"     = Cur_modcol.Cd_Varia
          AND "TipoAna"      = Cur_modcol.Tipoana
          AND "Cd_Ana"       = Cur_modcol.Cd_Ana
          AND "Cd_Artico"    = Cur_modcol.Cd_Artico
          AND "Cd_Cart"      = Cur_modcol.Cd_Cart
          AND "Cd_Colore"    = Cur_modcol.Cd_Colore;
          commit;
          v_modelli_par_col_upd := v_modelli_par_col_upd + 1;
        exception when others then
          v_error := sqlerrm;
          s3ksysmess.Batch_Messaggi(60071 ,sysdate,
	                        'Modelli Colore'||sqlerrm);
          v_modelli_par_col_err := v_modelli_par_col_err + 1;
          rollback;
        END;
      when others then
        v_error := sqlerrm;
        s3ksysmess.Batch_Messaggi(60071 ,sysdate,
                         'Modelli Colore'||sqlerrm);
        v_modelli_par_col_err := v_modelli_par_col_err + 1;
        rollback;
    END;
  END LOOP;
  exception when others then
      s3ksysmess.Batch_Messaggi(1583,sysdate,
                         'Modelli Colore: ',sqlerrm);
    END;
\end{lstlisting}
In un sistema Eterogeneo, ovvero in ui i database collegati dal DbLink sono diversi, come in questo caso tra Oracle e Sql Server, il riferimento ai campi dati di una tabella remota vanno specificati utilizzando il doppio apice ad inizio e fine, ed il nome è \textit{case sensitive}.\\
I dati estratti dal cursore per essere riversati nella tabella remota sono filtrati per la data impostata precedentemente, in fase di caricamento della tabella locale.
Quanto emerso da elaborazioni su set ristretti di dati, i DbLink in un sistema eterogeneo sono piuttosto lenti, nel caso specifico vengono trasferiti circa 1200 record al secondo in inserimento, mentre circa la metà in fase di modifica data la presenza di condizioni di filtro (nella clausola WHERE) che necessariamente rallentano l'esecuzione. Inoltre la decisione di eseguire una \textbf{commit} ad ogni record, utile per avere dei dati in fase di esecuzione in caso il programma sia molto lungo nella sua esecuzione, rallenta il processo, rispetto ad avere una singola commit alla fine dell'esecuzione, al costo ovviamente di non aver inserito nessuna riga in caso di un qualsiasi errore.\\
Nel complesso, l'autonomia dell'esecuzione, e soprattutto la decisione di schedulare il programma ogni notte per rendere marginale la questione della velocità di esecuzione, permettono di avere un vantaggio rispetto alla versione attuale del programma.
\subsection{Sviluppo programma di import}
La versione iniziale del programma di import è stata sviluppata nel 2002 da uno dei programmatori attualmente presenti in azienda e si basa su[...] \\


\subsection{Creazione report di import}
I report generati dal programma di import si basano su dati presenti nel database, per cui l'aggiornamento del progetto non ne comporta importanti modifiche; è comunque stato richiesto un minimo intervento in ottica migliorativa [...]\\